# 6장 도메인 객체의 생명주기

# 팩토리

객체는 객체의 존재 이유와 관련이 없거나 다른 객체와 상호작용할 때 해당 객체의 역할을 보조하지 않는것이 아무것도 남지 않을 때 까지 정제해야 한다. 이것만으로도 복잡한데 객체 생성의 책임까지 객체 자신에게 맡기는건 복잡도만 올릴 뿐이다. 

자동차 엔진을 예로 들면 엔진의 역할은 축을 회전시키는 것이다. 부품을 조립해 엔진을 만들어 내는건 공장의 로봇이 수행한다. 엔진을 조립하는 로봇은 실제로 차량이 주행중일때는 아무런 역할을 하지 않는다. 

→ SW에서도 마찬가지로 복잡한 객체를 조립하는 일은 객체의 진짜 책임과는 관련성이 적다.

그렇다고 객체를 사용하는 클라이언트가 객체를 생성하도록 하기 위해서는 객체의 내부 구조를 드러내야 한다. 이는 클라이언트의 코드와 클라이언트가 사용할 객체 코드의 결합도를 높인다. (객체의 변경이 곧 클라이언트의 변경으로 전파되기 때문)

→ 리팩터링 내성이 낮아진다.

만약 클라이언트가 응용 계층이라면 도메인 계층의 책임이 응용 계층으로 섞이게 된다.

→ 도메인 계층이라는 추상화 계층을 도입한 이점이 줄어든다.

### 팩토리

- 도메인 모델로서는 아무런 의미 없음
- 다른 객체를 생성하는것이 책임인 프로그램 요소

팩토리는 복잡한 객체나 애그리거트를 생성하기 위한 지식을 팩토리의 기능으로 추상화하여 클라이언트에게 제공한다. 

## 팩토리 위치선정

### 애그리거트 루트

이미 존재하는 애그리거트에 새로운 인스턴스를 추가해야 한다면 애그리거트 루트에 팩터리를 둘 수 있다.

e.x. 주문 리스트에 새로운 주문 아이템 인스턴스를 추가하는 경우

또는 별도의 애그리거트에 속하는 엔티티를 만들어서 리턴할 수도 있다.

e.x. 증권 계좌 엔티티가 별개의 애그리거트에 속하는 증권 거래 주문 엔티티를 생성

### 전용 팩토리

복잡한 전체 애그리거트를 생성하여 루트 애그리거트에 대한 참조를 건내줄때는 대개 전용 팩토리 객체를 둔다.

e.x. 계좌 팩토리가 계좌번호 채번 시퀀스를 찔러서 신규 계좌번호를 가져오고, 가져온 계좌번호를 통해 새로운 계좌 객체를 조립하여 애그리거트를 생성

## 생성자만으로 충분한 경우

- 생성자가 복잡하지 않은 경우
- 인터페이스 - 구체클래스의 계층관계를 구성하지 않고 다형적이지 않은 경우
- 클라이언트가 Strategy를 선택하는 방법으로서 구현체에 관심이 있는 경우

## 인터페이스 설계

팩토리 인터페이스 설계에서 고려애햐 할 사항들

- 각 연산은 원자적이어야 한다.
- 팩토리에 주입되는 인자로 인한 결합도를 고려해라.
- 구체 클래스가 아닌 추상 클래스를 인자로 받아라

## 불변식 로직의 위치

불변식 로직을 팩토리에 둘 수도 있다. 예를 들어 엔티티의 식별 값은 객체가 한 번 생성되고 나면 절대 불변하는 값이다. 이런 경우 불변식 로직을 객체가 아닌 팩토리에 두면 엔티티 객체의 생성자를 더 단순하게 만들 수 있다.

## 요약

객체 인스턴스 생성은 생성자가 될 수도 있지만, 더욱 추상적이고 정교한 메커니즘을 위해 팩토리를 도입할 수도 있다. 팩토리는 모델을 표현하지는 않지만 객체를 만들기 위한 도메인 설계의 일부분에 속한다. 팩토리는 객체의 생명주기 중 생성과 재구성을 캡슐화한다.